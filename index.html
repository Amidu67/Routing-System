<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <meta http-equiv="x-ua-compatible" content="IE=edge">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Devtraco Estate Navigation</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; font-family: Arial, sans-serif; }

    .navbar {
      position: absolute; top: 10px; right: 20px; z-index: 1000;
    }
    .navbar a {
      background: #007bff; color: white; padding: 8px 15px;
      margin-left: 10px; text-decoration: none; border-radius: 4px;
      transition: 0.3s;
    }
    .navbar a:hover { background: #0056b3; }

    .page { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .active { display: block; }

    #home {
      background: url('https://devtraco.com/wp-content/uploads/2021/01/Untitled-design-2.jpg') center/cover no-repeat;
      display: flex; flex-direction: column; justify-content: flex-start; align-items: center;
      text-align: center; color: rgb(255, 255, 255); padding-top: 80px;
    }
    #home h1 {
      font-size: 3em; margin-bottom: 10px;
      color: #ffcc00;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8);
    }
    #home p { max-width: 600px; font-size: 1.33em; padding: 0 20px; margin-bottom: 20px; color: rgb(248, 249, 249); }
    button {
      padding: 15px 25px; background: #28a745; color: white;
      border: none; border-radius: 5px; cursor: pointer;
    }
    button:hover { background: #1e7e34; }

    .sentence-box {
      background-color: rgba(0, 0, 0, 0.6);
      border: 2px solid #ffcc00;
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
      max-width: 600px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    #about {
      background: url('https://devtraco.com/wp-content/uploads/2021/01/Untitled-design-1.jpg') center/cover no-repeat;
      color: white;
      position: relative;
    }
    #about::before {
      content: "";
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1;
    }
    #about .content {
      position: relative;
      z-index: 2;
      padding: 80px 40px;
      text-align: center;
      max-width: 800px;
      margin: 0 auto;
    }
    #about .content button {
      margin-top: 30px;
    }

    #contact {
      background: #2c3e50; color: white; padding: 80px 40px;
    }

    #mapPage { background: white; color: #333; }
    #map { height: 100%; width: 100%; }

    .return-btn {
      position: absolute; top: 80px; left: 10px; z-index: 1000;
      background: #dc3545; color: white; border: none;
      padding: 8px 15px; border-radius: 4px;
    }

    .search-bar {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: white;
      padding: 8px;
      border-radius: 4px;
      display: flex;
      gap: 8px;
      align-items: center;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .search-bar input {
      padding: 10px;
      width: 500px;
      font-size: 1em;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
    .search-bar button {
      padding: 10px 15px; background: #007bff; color: white;
      border: none; border-radius: 3px; font-size: 1em;
    }

    .leaflet-routing-container {
      margin-top: 120px !important;
    }

    .blinking {
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .gps-accuracy {
      stroke: #0078A8;
      stroke-width: 1;
      fill: #0078A8;
      fill-opacity: 0.15;
      pointer-events: none;
    }

    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      border: 5px solid rgba(243, 243, 243, 0.8);
      border-top: 5px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      background-color: rgba(255,255,255,0.8);
      display: none;
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    .recenter-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: #007bff;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    .voice-controls {
      position: absolute;
      bottom: 70px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .voice-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    #search-results {
      position: absolute;
      top: 100%;
      left: 0;
      width: 100%;
      max-height: 300px;
      overflow-y: auto;
      background: white;
      border: 1px solid #ccc;
      border-radius: 0 0 4px 4px;
      z-index: 1001;
      display: none;
    }
    .search-result {
      padding: 10px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }
    .search-result:hover {
      background-color: #f5f5f5;
    }

    .route-line {
      stroke: #0066ff;
      stroke-width: 5;
      stroke-opacity: 0.9;
      stroke-dasharray: 20, 5;
      animation: dash 0.5s linear infinite;
    }

    @keyframes dash {
      0% { stroke-dashoffset: 25; }
      100% { stroke-dashoffset: 0; }
    }

    .route-line-upcoming {
      stroke: #66ccff;
      stroke-width: 4;
      stroke-opacity: 0.5;
    }

    .leaflet-popup-content-wrapper {
      border-radius: 8px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
    }
    .leaflet-popup-content {
      margin: 10px;
      text-align: center;
    }
    .leaflet-popup-content img {
      max-width: 250px;
      max-height: 250px;
      margin-top: 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }

    .transport-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .transport-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background: #f8f9fa;
      cursor: pointer;
      transition: all 0.2s;
    }

    .transport-btn:hover {
      background: #e9ecef;
    }

    .transport-btn.active {
      background: #007bff;
      color: white;
    }

    .transport-btn i {
      font-size: 18px;
    }

    .distance-info {
      position: absolute;
      top: 80px;
      right: 20px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-size: 14px;
      display: none;
    }

    .distance-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      min-width: 200px;
    }

    .distance-row span:first-child {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .distance-row span:last-child {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .distance-value {
      font-weight: bold;
      display: none; /* Hide distance value */
    }

    .time-value {
      font-size: 0.9em;
      color: #666;
    }

    .distance-row.active {
      font-weight: bold;
      color: #007bff;
    }

    .distance-row.active .time-value {
      color: #007bff;
    }

    @media (max-width: 768px) {
      .search-bar {
        width: 90%;
      }
      .search-bar input {
        width: 100%;
      }
      #home h1 {
        font-size: 2em;
      }
      .transport-controls {
        bottom: 80px;
        flex-direction: row;
      }
      .distance-info {
        top: 120px;
        right: 10px;
        left: 10px;
      }
    }
  </style>
</head>
<body>

<div class="navbar" id="navLinks">
  <a href="#" onclick="show('home')">Home</a>
  <a href="#" onclick="show('about')">About</a>
  <a href="#" onclick="show('contact')">Contact</a>
</div>

<div id="home" class="page active">
  <h1>Welcome to Devtraco Estate</h1>
  <div class="sentence-box">
    <p>Explore Devtraco with live GPS navigation, voice-guided directions, and seamless search functionality.</p>
  </div>
  <button id="startNavBtn">Start Navigation</button>
</div>

<div id="about" class="page">
  <div class="content">
    <h2>About Devtraco Estate</h2>
    <p>Devtraco Estate is a premier residential community located in the serene area of Tema Community 25, Accra, Ghana. It offers high-quality housing units with modern amenities, reliable security systems, excellent roads, and access to schools, hospitals, and shopping centers.</p>
    <p>Visit: <a href="https://devtraco.com" target="_blank" style="color: #ffcc00;">https://devtraco.com</a></p>
    <button onclick="show('home')">Return</button>
  </div>
</div>

<div id="contact" class="page">
  <div class="content">
    <h2>Contact Us</h2>
    <p>
      For inquiries and support:<br>
      üìß Email: Devtraco444@esta.com<br>
      ‚òé Phone: +233‚ÄØ302‚ÄØ812‚ÄØ000<br>
      üìç Address: Devtraco Courts, Community 25, Tema, Ghana
    </p>
    <button onclick="show('home')">Return</button>
  </div>
</div>

<div id="mapPage" class="page">
  <button class="return-btn" onclick="show('home')">&larr; Back</button>
  <div class="search-bar">
    <input type="text" id="searchInput" placeholder="Search house number or location in Ghana"/>
    <button onclick="doSearch()">Search</button>
    <div id="search-results"></div>
  </div>
  <div id="map"></div>
  <div id="loadingSpinner" class="loading-spinner" style="display: none;"></div>
  
  <div class="distance-info" id="distanceInfo">
    <div class="distance-row" id="walkingDistance">
      <span><i class="fas fa-walking"></i> Walking:</span>
      <span>
        <span class="time-value" id="walkingTimeValue">-</span>
      </span>
    </div>
    <div class="distance-row" id="bikingDistance">
      <span><i class="fas fa-bicycle"></i> Biking:</span>
      <span>
        <span class="time-value" id="bikingTimeValue">-</span>
      </span>
    </div>
    <div class="distance-row" id="drivingDistance">
      <span><i class="fas fa-car"></i> Driving:</span>
      <span>
        <span class="time-value" id="drivingTimeValue">-</span>
      </span>
    </div>
  </div>
  
  <div class="transport-controls">
    <button class="transport-btn active" id="walkingBtn" onclick="setTransportMode('walking')">
      <i class="fas fa-walking"></i> Walk
    </button>
    <button class="transport-btn" id="bikingBtn" onclick="setTransportMode('biking')">
      <i class="fas fa-bicycle"></i> Bike
    </button>
    <button class="transport-btn" id="drivingBtn" onclick="setTransportMode('driving')">
      <i class="fas fa-car"></i> Drive
    </button>
  </div>
  
  <div class="voice-controls">
    <button class="voice-btn" onclick="toggleVoice()" title="Toggle voice guidance" id="voiceToggleBtn">üîä</button>
  </div>
  <button class="recenter-btn" onclick="recenterMap()" title="Recenter on my location">üìç</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>

<script>
  let map, routingControl, userMarker, accuracyCircle, userPos = [], instructions = [];
  let watchId = null;
  let lastSpokenInstruction = null;
  let nextInstructionIndex = 0;
  let isNavigating = false;
  let houseData = [];
  let roadData = [];
  let highlightedHouse = null;
  let periodicUpdateInterval = null;
  let currentRoute = null;
  let voiceEnabled = true;
  let audioContextInitialized = false;
  let lastPosition = null;
  let currentTransportMode = 'walking';
  let currentDestination = null;
  let routeCalculating = false;
  let distanceCache = {
    walking: { distance: null, duration: null },
    biking: { distance: null, duration: null },
    driving: { distance: null, duration: null }
  };

  const estateBounds = {
    minLat: 5.7260,
    maxLat: 5.7400,
    minLon: 0.0390,
    maxLon: 0.0500
  };

  function initAudioContext() {
    if (audioContextInitialized) return;
    try {
      if (typeof AudioContext !== 'undefined') {
        new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        new webkitAudioContext();
      }
      audioContextInitialized = true;
      console.log("AudioContext initialized successfully");
    } catch (e) {
      console.warn("AudioContext initialization failed:", e);
    }
  }

  function speak(text) {
    if (!voiceEnabled) return;
    if (!window.speechSynthesis) {
      console.warn("Speech synthesis not supported");
      return;
    }
    try {
      initAudioContext();
      window.speechSynthesis.cancel();
      const speakUtterance = () => {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = 'en-US';
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        if (isIOS) {
          utter.rate = 0.9;
          utter.volume = 1.0;
          utter.pitch = 1.0;
        } else if (/Android/i.test(navigator.userAgent)) {
          utter.rate = 1.0;
          utter.volume = 1.5;
        } else {
          utter.rate = 0.9;
          utter.volume = 1.0;
        }
        const voices = window.speechSynthesis.getVoices();
        let selectedVoice = voices.find(v => v.name.includes('Siri') || v.name.includes('Female') || v.name.includes('woman'));
        if (!selectedVoice) {
          selectedVoice = voices.find(v => v.lang === 'en-US') || voices[0];
        }
        if (selectedVoice) {
          utter.voice = selectedVoice;
        }
        utter.onerror = function(event) {
          console.error("SpeechSynthesis error:", event);
        };
        window.speechSynthesis.speak(utter);
        lastSpokenInstruction = text;
      };
      if (window.speechSynthesis.getVoices().length === 0) {
        window.speechSynthesis.onvoiceschanged = speakUtterance;
      } else {
        speakUtterance();
      }
    } catch (e) {
      console.error("Error in speak function:", e);
    }
  }

  function toggleVoice() {
    voiceEnabled = !voiceEnabled;
    console.log("Voice enabled:", voiceEnabled);
    document.getElementById('voiceToggleBtn').textContent = voiceEnabled ? 'üîä' : 'üîá';
    if (voiceEnabled && lastSpokenInstruction) {
      speak(lastSpokenInstruction);
    }
  }

  function startPeriodicVoiceUpdates() {
    if (periodicUpdateInterval) {
      clearInterval(periodicUpdateInterval);
    }
    lastPosition = userPos.length ? [...userPos] : null;
    periodicUpdateInterval = setInterval(() => {
      if (isNavigating && instructions.length > 0 && voiceEnabled && userPos.length && lastPosition) {
        const distanceMoved = map.distance(userPos, lastPosition);
        if (distanceMoved > 10) {
          const currentInstruction = instructions[nextInstructionIndex];
          if (currentInstruction) {
            speak(`Next instruction: ${currentInstruction.text}.`);
          } else if (nextInstructionIndex >= instructions.length - 1) {
            const distanceToDest = map.distance(userPos, instructions[instructions.length - 1].latLng);
            if (distanceToDest < 20) {
              speak(`You have arrived at your destination.`);
              clearInterval(periodicUpdateInterval);
              periodicUpdateInterval = null;
            } else {
              speak(`Continue towards your destination.`);
            }
          }
        }
        lastPosition = userPos.length ? [...userPos] : null;
      }
    }, 300000); // 5 minutes
  }

  document.addEventListener('DOMContentLoaded', function() {
    try {
      const startNavBtn = document.getElementById('startNavBtn');
      if (!startNavBtn) {
        console.error("Start Navigation button not found");
        return;
      }
      startNavBtn.addEventListener('click', function() {
        console.log("Start Navigation button clicked");
        initAudioContext();
        try {
          if (window.speechSynthesis && window.speechSynthesis.getVoices().length > 0) {
            speak("Welcome to Devtraco Estate Navigation System");
          } else if (window.speechSynthesis) {
            window.speechSynthesis.onvoiceschanged = function() {
              console.log("Voices loaded:", window.speechSynthesis.getVoices());
              speak("Welcome to Devtraco Estate Navigation System");
            };
          }
        } catch (e) {
          console.error("Error speaking welcome message:", e);
        }
        show('map');
      });
    } catch (e) {
      console.error("Error setting up startNavBtn:", e);
    }
  });

  function show(id) {
    console.log("Showing page:", id);
    try {
      document.querySelectorAll('.page').forEach(e => e.classList.remove('active'));
      document.getElementById(id === 'map' ? 'mapPage' : id).classList.add('active');
      document.getElementById('navLinks').style.display = (id === 'map') ? 'none' : 'block';
      if (id === 'map') {
        setTimeout(() => {
          try {
            initMap();
          } catch (e) {
            console.error("Error initializing map:", e);
          }
        }, 300);
      } else {
        if (periodicUpdateInterval) {
          clearInterval(periodicUpdateInterval);
          periodicUpdateInterval = null;
        }
      }
    } catch (e) {
      console.error("Error in show function:", e);
    }
  }

  function setTransportMode(mode) {
    if (currentTransportMode === mode) return;
    
    currentTransportMode = mode;
    
    // Update button styles
    document.querySelectorAll('.transport-btn').forEach(btn => {
      btn.classList.remove('active');
    });
    document.getElementById(`${mode}Btn`).classList.add('active');
    
    // Update distance display
    document.querySelectorAll('.distance-row').forEach(row => {
      row.classList.remove('active');
    });
    document.getElementById(`${mode}Distance`).classList.add('active');
    
    // Recalculate route if we have a destination
    if (currentDestination) {
      calculateRoute(currentDestination);
    }
    
    if (voiceEnabled) {
      speak(`Transport mode set to ${mode}`);
    }
  }

  function formatDistance(distance) {
    // Return empty string to hide distance display
    return "";
  }

  function formatDuration(seconds) {
    if (seconds === null) return "-";
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.round((seconds % 3600) / 60);
    
    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    }
    return `${minutes} min`;
  }

  function calculateDuration(distance, mode) {
    // Approximate speeds in meters per second
    const speeds = {
        walking: 1.4,  // ~5 km/h
        biking: 4.2,   // ~15 km/h
        driving: 13.9  // ~50 km/h
    };
    return distance / speeds[mode];
  }

  function getProfileForMode(mode) {
    switch(mode) {
      case 'driving': return 'driving';
      case 'biking': return 'cycling';
      case 'walking': 
      default: return 'foot';
    }
  }

  function handleRoutingError() {
    document.getElementById('loadingSpinner').style.display = 'none';
    if (voiceEnabled) speak("Unable to calculate route. Please try a different location.");
    if (periodicUpdateInterval) {
      clearInterval(periodicUpdateInterval);
      periodicUpdateInterval = null;
    }
    routeCalculating = false;
    
    // Fallback to straight line if routing fails
    if (currentDestination) {
      const straightDistance = map.distance(userPos, currentDestination);
      const duration = calculateDuration(straightDistance, currentTransportMode);
      distanceCache[currentTransportMode] = {
        distance: straightDistance,
        duration: duration
      };
      
      document.getElementById(`${currentTransportMode}TimeValue`).textContent = 
        formatDuration(duration);
      
      const straightLine = L.polyline([userPos, currentDestination], {
        color: '#ff0000',
        weight: 3,
        dashArray: '10, 10',
        opacity: 0.7
      }).addTo(map);
      
      setTimeout(() => map.removeLayer(straightLine), 5000);
    }
  }

  async function calculateAllRouteDistances(destination) {
    const modes = [
      { mode: 'walking', profile: 'foot' },
      { mode: 'biking', profile: 'cycling' },
      { mode: 'driving', profile: 'driving' }
    ];

    // Reset distances
    modes.forEach(m => {
      distanceCache[m.mode] = { distance: null, duration: null };
      document.getElementById(`${m.mode}TimeValue`).textContent = '-';
    });

    // Calculate distances for all modes in sequence (not parallel to avoid API rate limits)
    for (const { mode, profile } of modes) {
      try {
        const router = L.Routing.osrmv1({
          serviceUrl: 'https://router.project-osrm.org/route/v1',
          profile: profile,
          timeout: 10000
        });

        const routes = await new Promise((resolve, reject) => {
          router.route([
            L.latLng(userPos[0], userPos[1]),
            L.latLng(destination[0], destination[1])
          ], (err, routes) => {
            if (err) {
              console.log(`No ${mode} route found, using straight line distance`);
              const straightDistance = map.distance(userPos, destination);
              const duration = calculateDuration(straightDistance, mode);
              distanceCache[mode] = {
                distance: straightDistance,
                duration: duration
              };
              document.getElementById(`${mode}TimeValue`).textContent = 
                formatDuration(duration);
              resolve([]);
            } else {
              resolve(routes);
            }
          });
        });

        if (routes && routes[0]) {
          distanceCache[mode] = {
            distance: routes[0].summary.totalDistance,
            duration: routes[0].summary.totalTime
          };
          document.getElementById(`${mode}TimeValue`).textContent = 
            formatDuration(routes[0].summary.totalTime);
        }
      } catch (err) {
        console.error(`Error calculating ${mode} route:`, err);
        // Fallback to straight line distance if routing fails
        const straightDistance = map.distance(userPos, destination);
        const duration = calculateDuration(straightDistance, mode);
        distanceCache[mode] = {
          distance: straightDistance,
          duration: duration
        };
        document.getElementById(`${mode}TimeValue`).textContent = 
          formatDuration(duration);
      }
      
      // Small delay between requests to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    document.getElementById('distanceInfo').style.display = 'block';
  }

  async function calculateRoute(destination) {
    if (routeCalculating) return;
    routeCalculating = true;
    currentDestination = destination;
    document.getElementById('loadingSpinner').style.display = 'block';
    
    if (!userPos.length) {
      if (voiceEnabled) speak("Please enable location services to get directions.");
      document.getElementById('loadingSpinner').style.display = 'none';
      routeCalculating = false;
      return;
    }

    try {
      // First calculate all distances
      await calculateAllRouteDistances(destination);
      
      // Then proceed with the actual route calculation for the selected mode
      if (routingControl) {
        map.removeControl(routingControl);
      }

      const profile = getProfileForMode(currentTransportMode);

      routingControl = L.Routing.control({
        waypoints: [
          L.latLng(userPos[0], userPos[1]),
          L.latLng(destination[0], destination[1])
        ],
        routeWhileDragging: false,
        showAlternatives: false,
        addWaypoints: false,
        draggableWaypoints: false,
        fitSelectedRoutes: true,
        lineOptions: {
          styles: [
            { color: '#0066ff', weight: 5, opacity: 0.8 },
            { color: '#66ccff', weight: 4, opacity: 0.5 }
          ]
        },
        createMarker: () => null,
        router: L.Routing.osrmv1({
          serviceUrl: 'https://router.project-osrm.org/route/v1',
          profile: profile,
          timeout: 15000
        })
      }).addTo(map);

      routingControl.on('routestart', () => {
        document.getElementById('loadingSpinner').style.display = 'block';
      });

      routingControl.on('routesfound', (e) => {
        try {
          document.getElementById('loadingSpinner').style.display = 'none';
          currentRoute = e.routes[0];
          instructions = e.routes[0].instructions;
          nextInstructionIndex = 0;
          isNavigating = true;
          
          const cachedData = distanceCache[currentTransportMode];
          
          if (voiceEnabled) {
            speak(`Route calculated. Estimated time: ${formatDuration(cachedData.duration)}.`);
          }
          
          startPeriodicVoiceUpdates();
        } catch (e) {
          console.error("Error in routesfound:", e);
        } finally {
          routeCalculating = false;
        }
      });

      routingControl.on('routingerror', (e) => {
        console.error("Routing error:", e);
        // Fallback to straight line if routing fails
        const straightDistance = map.distance(userPos, destination);
        const duration = calculateDuration(straightDistance, currentTransportMode);
        distanceCache[currentTransportMode] = {
          distance: straightDistance,
          duration: duration
        };
        
        document.getElementById(`${currentTransportMode}TimeValue`).textContent = 
          formatDuration(duration);
        
        const straightLine = L.polyline([userPos, destination], {
          color: '#ff0000',
          weight: 3,
          dashArray: '10, 10',
          opacity: 0.7
        }).addTo(map);
        
        setTimeout(() => map.removeLayer(straightLine), 5000);
        
        if (voiceEnabled) {
          speak(`Estimated time: ${formatDuration(duration)}.`);
        }
        
        document.getElementById('loadingSpinner').style.display = 'none';
        routeCalculating = false;
      });

    } catch (error) {
      console.error("Error in calculateRoute:", error);
      handleRoutingError();
    }
  }

  function initMap() {
    console.log("Initializing map");
    if (map) return;

    try {
      document.getElementById('loadingSpinner').style.display = 'block';

      map = L.map('map').setView([5.7328, 0.0447], 14);

      const streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors'
      });

      const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: '¬© Esri, Maxar, Earthstar Geographics'
      });

      const labelsLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}.png', {
        attribution: '¬© CartoDB'
      });

      const baseLayers = {
        "Street": streetLayer,
        "Satellite with Labels": L.layerGroup([satelliteLayer, labelsLayer])
      };

      streetLayer.addTo(map);
      L.control.layers(baseLayers).addTo(map);

      fetch('Building_point.json')
        .then(response => {
          if (!response.ok) throw new Error('Failed to load house GeoJSON');
          return response.json();
        })
        .then(data => {
          houseData = data.features;
          console.log(`Loaded ${houseData.length} buildings`);
        })
        .catch(error => {
          console.error('Error loading house data:', error);
          houseData = [{
            "type":"Feature",
            "id":54,
            "geometry":{
              "type":"Point",
              "coordinates":[0.046657388234413413,5.7315854133107598]
            },
            "properties":{
              "FID":54,
              "TARGET_FID":1146,
              "OBJECTID_1":1140,
              "Northings":385586.78672799998,
              "Eastings":1280192.4411299999,
              "CreationDa":1752624000000,
              "Creator":"sfiatuga",
              "EditDate":1754092800000,
              "Editor":"sfiatuga",
              "HOUSE_NUMB":"SS14",
              "ORIG_FID":55,
              "Image_URL":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRMNYAE53rdANIf0M0s82pbE9L8S6-c6s_fVQ&s"
            }
          }];
        });

      const geoOptions = {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      };

      navigator.geolocation.getCurrentPosition(
        (p) => {
          console.log("Geolocation success:", p.coords);
          updateUserPosition(p);
          document.getElementById('loadingSpinner').style.display = 'none';
        },
        (error) => {
          console.error("Geolocation error:", error);
          handleLocationError(error);
          document.getElementById('loadingSpinner').style.display = 'none';
        },
        geoOptions
      );

      watchId = navigator.geolocation.watchPosition(
        updateUserPosition,
        handleLocationError,
        geoOptions
      );

      const searchInput = document.getElementById('searchInput');
      const searchResults = document.getElementById('search-results');
      
      searchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.trim().toUpperCase();
        searchResults.innerHTML = '';
        
        if (searchTerm.length < 1) {
          searchResults.style.display = 'none';
          return;
        }
        
        const houseMatches = houseData.filter(house => 
          house.properties.HOUSE_NUMB && 
          house.properties.HOUSE_NUMB.toUpperCase().includes(searchTerm)
        ).slice(0, 5);
        
        houseMatches.forEach(house => {
          const resultItem = document.createElement('div');
          resultItem.className = 'search-result';
          resultItem.textContent = house.properties.HOUSE_NUMB;
          resultItem.addEventListener('click', () => {
            selectHouse(house);
            searchResults.style.display = 'none';
            searchInput.value = house.properties.HOUSE_NUMB;
          });
          searchResults.appendChild(resultItem);
        });
        
        searchResults.style.display = houseMatches.length > 0 ? 'block' : 'none';
      });
      
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.search-bar')) {
          searchResults.style.display = 'none';
        }
      });

      document.getElementById('loadingSpinner').style.display = 'none';
    } catch (e) {
      console.error("Error in initMap:", e);
      document.getElementById('loadingSpinner').style.display = 'none';
    }
  }

  function updateUserPosition(position) {
    try {
      const lat = position.coords.latitude;
      const lon = position.coords.longitude;
      const accuracy = Math.min(position.coords.accuracy, 20);
      
      userPos = [lat, lon];
      
      const customIcon = L.icon({
        iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        className: 'blinking'
      });

      if (userMarker) {
        userMarker.setLatLng(userPos);
      } else {
        userMarker = L.marker(userPos, { icon: customIcon }).addTo(map);
      }

      if (accuracyCircle) {
        accuracyCircle.setLatLng(userPos).setRadius(accuracy);
      } else {
        accuracyCircle = L.circle(userPos, {
          radius: accuracy,
          className: 'gps-accuracy'
        }).addTo(map);
      }

      if (isNavigating && instructions.length > 0) {
        checkNextInstruction();
      }
    } catch (e) {
      console.error("Error in updateUserPosition:", e);
    }
  }

  function checkNextInstruction() {
    try {
      if (!isNavigating || nextInstructionIndex >= instructions.length) return;

      const currentInstruction = instructions[nextInstructionIndex];
      const distanceToNext = map.distance(userPos, currentInstruction.latLng);
      const distanceMoved = userPos.length && lastPosition ? map.distance(userPos, lastPosition) : 0;

      if (distanceMoved > 10 && distanceToNext < 50) {
        if (voiceEnabled) speak(currentInstruction.text);
        nextInstructionIndex++;
        
        if (nextInstructionIndex < instructions.length && distanceToNext < 150) {
          const nextInstruction = instructions[nextInstructionIndex];
          if (voiceEnabled) speak(`After that, ${nextInstruction.text}`);
        }
      } else if (nextInstructionIndex === instructions.length - 1 && distanceToNext < 20) {
        if (voiceEnabled) speak(`You have arrived at your destination`);
        isNavigating = false;
        if (periodicUpdateInterval) {
          clearInterval(periodicUpdateInterval);
          periodicUpdateInterval = null;
        }
      }
    } catch (e) {
      console.error("Error in checkNextInstruction:", e);
    }
  }

  function handleLocationError(error) {
    try {
      let errorMsg = "Error getting your location: ";
      switch(error.code) {
        case error.PERMISSION_DENIED:
          errorMsg += "Location permission denied. Please enable it in your browser settings.";
          break;
        case error.POSITION_UNAVAILABLE:
          errorMsg += "Location information unavailable.";
          break;
        case error.TIMEOUT:
          errorMsg += "Location request timed out. Please try again.";
          break;
        case error.UNKNOWN_ERROR:
          errorMsg += "An unknown error occurred.";
          break;
      }
      console.error(errorMsg);
      if (voiceEnabled) speak(errorMsg);
      
      userPos = [5.7328, 0.0447];
      if (userMarker) {
        userMarker.setLatLng(userPos);
      } else {
        const customIcon = L.icon({
          iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          className: 'blinking'
        });
        userMarker = L.marker(userPos, { icon: customIcon }).addTo(map);
      }
      map.setView(userPos, 15);
    } catch (e) {
      console.error("Error in handleLocationError:", e);
    }
  }

  function recenterMap() {
    try {
      if (userPos.length) {
        map.setView(userPos, 15);
      } else {
        console.warn("No user position available for recentering");
      }
    } catch (e) {
      console.error("Error in recenterMap:", e);
    }
  }

  function doSearch() {
    try {
      const q = document.getElementById('searchInput').value;
      if (!q || !userPos.length) {
        if (voiceEnabled) speak("Please enter a search term and ensure location services are enabled.");
        return;
      }
      
      const houseMatch = houseData.find(house => 
        house.properties.HOUSE_NUMB && 
        house.properties.HOUSE_NUMB.toUpperCase() === q.toUpperCase()
      );
      
      if (houseMatch) {
        selectHouse(houseMatch);
        return;
      }
      
      fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q + ' Ghana')}`)
        .then(res => res.json())
        .then(data => {
          if (!data.length) {
            if (voiceEnabled) speak("Location not found. Please try another search term.");
            return;
          }
          const dest = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
          calculateRoute(dest);
        })
        .catch(err => {
          console.error('Search error:', err);
          if (voiceEnabled) speak("Error searching for location. Please try again.");
        });
    } catch (e) {
      console.error("Error in doSearch:", e);
    }
  }

  function selectHouse(house) {
    try {
      if (highlightedHouse) {
        map.removeLayer(highlightedHouse);
      }
      
      const houseCoords = house.geometry.coordinates;
      const houseLatLng = [houseCoords[1], houseCoords[0]];

      map.flyTo(houseLatLng, 18);

      const houseIcon = L.icon({
        iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
        shadowSize: [41, 41]
      });
      
      let popupContent = `<b>House:</b> ${house.properties.HOUSE_NUMB}`;
      if (house.properties.Image_URL) {
        popupContent += `<br><img src="${house.properties.Image_URL}" style="max-width:250px; max-height:250px; margin-top:10px;">`;
      }
      
      highlightedHouse = L.marker(houseLatLng, { icon: houseIcon })
        .addTo(map)
        .bindPopup(popupContent)
        .openPopup();

      calculateRoute(houseLatLng);
    } catch (e) {
      console.error("Error in selectHouse:", e);
    }
  }

  function isInEstate(lat, lon) {
    try {
      return lat >= estateBounds.minLat && lat <= estateBounds.maxLat &&
             lon >= estateBounds.minLon && lon <= estateBounds.maxLon;
    } catch (e) {
      console.error("Error in isInEstate:", e);
      return false;
    }
  }

  window.addEventListener('beforeunload', () => {
    try {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
      }
      if (periodicUpdateInterval) {
        clearInterval(periodicUpdateInterval);
      }
      window.speechSynthesis.cancel();
    } catch (e) {
      console.error("Error in beforeunload:", e);
    }
  });
</script>
</body>
</html>